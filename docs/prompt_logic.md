# プロンプト生成ロジック解説 (Project Wannabe 内部仕様)

このドキュメントは、Project Wannabe アプリケーション内部で、ユーザーの操作とUIの状態に応じて、KoboldCpp APIに送信する最終的なプロンプト文字列がどのように組み立てられるかを解説します。

**参照コード:** `src/core/prompt_builder.py`

---

## Part 1: Current Prompt Logic (新仕様)

このセクションでは、現在の `main` ブランチ（旧 `dev` ブランチ）におけるプロンプト生成ロジックを説明します。このロジックは、AIの出力品質安定化、特に継続タスクの改善を目的とした変更が加えられており、新モデルの学習データ形式とも関連しています。

### 1.1 基本的な流れ (Current)

1.  **UIデータ収集:** 現在のモード、本文、詳細情報タブの全データ（メタデータ、レーティング、オーサーズノート）を取得します。
2.  **タスク判定:** UIの状態（特に本文の行数）に基づき、内部タスクタイプ (`GEN_INFO`, `GEN_ZERO`, `CONT_INFO`, `CONT_ZERO`, `IDEA_INFO`, `IDEA_ZERO`) を決定します。
3.  **Instruction 選択と整形:** タスクタイプに対応する基本Instructionを選択し、UIから取得したレーティング情報を付加します。
4.  **Input および Suffix 生成:** タスクタイプに応じて、UIデータから `internal_input` 文字列（`[INST]`と`[/INST]`の間に入る部分）と `prompt_suffix` 文字列（`[/INST]`の後に付加される部分）を生成します。
5.  **最終プロンプト整形:** 整形されたInstruction、Input、Suffixを、Mistral Instruct形式のテンプレート (`<s>[INST]Instruction\nInput[/INST]Suffix`) に合わせて結合します。

### 1.2 タスク判定ロジック (Current)

`determine_task_and_instruction` 関数により、以下のロジックでタスクタイプが決定されます。

*   **メタデータ有無判定の厳密化:**
    *   `title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`, `dialogue_level` の各項目について、値が存在するか（空文字列や空リストでないか）を個別にチェックします。
    *   `generate` モードでは、これらのいずれか一つでも存在すれば「メタデータあり」と判定されます。
    *   `idea` モードでは、`dialogue_level` を除いたメタデータのいずれか一つでも存在すれば「メタデータあり」と判定されます。
*   **本文の行数に基づくタスクタイプの調整 (重要変更点):**
    *   `generate` モードで本文が入力されている場合、その本文の有効行数（空行やスペースのみの行を除いた行数）をカウントします。
    *   **有効行数が4行未満 (3行以下) の場合:** 継続タスク (`CONT_`) ではなく、新規生成タスク (`GEN_`) として扱われます。これは、短い本文を「書き出し」とみなし、それに続く形でAIに新規に文章を生成させることを目的としています。
    *   **有効行数が4行以上の場合:** 従来通り継続タスク (`CONT_`) として扱われます。
*   **タスクタイプ決定表:**

| 選択中のモード | 本文エリアの状態                                   | メタデータ有無 (上記判定) | 決定されるタスクタイプ |
| :------------- | :------------------------------------------------- | :------------------------ | :--------------------- |
| `generate`     | 空                                                 | あり                      | `GEN_INFO`             |
| `generate`     | 空                                                 | なし                      | `GEN_ZERO`             |
| `generate`     | 入力あり (有効行数 **3行以下**)                    | あり                      | `GEN_INFO`             |
| `generate`     | 入力あり (有効行数 **3行以下**)                    | なし                      | `GEN_ZERO`             |
| `generate`     | 入力あり (有効行数 **4行以上**)                    | あり                      | `CONT_INFO`            |
| `generate`     | 入力あり (有効行数 **4行以上**)                    | なし                      | `CONT_ZERO`            |
| `idea`         | (不問)                                             | あり (セリフ量除く)       | `IDEA_INFO`            |
| `idea`         | (不問)                                             | なし (セリフ量除く)       | `IDEA_ZERO`            |

### 1.3 Instructionテンプレートと整形 (Current)

1.  **基本テンプレート:** タスクタイプに応じて、以下の基本Instructionが選択されます。
    ```python
    # src/core/prompt_builder.py より
    INSTRUCTION_TEMPLATES = {
        "GEN_INFO": "以下の情報に基づいて小説本文を生成してください。",
        "GEN_ZERO": "自由に小説を生成してください。",
        "CONT_INFO": "参考情報と本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。",
        "CONT_ZERO": "本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。",
        "IDEA_INFO": "以下の情報に基づいて、完全な小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
        "IDEA_ZERO": "自由に小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
    }
    ```
2.  **レーティング付加:** UIの詳細情報タブで選択されたレーティング (`general` または `r18`)、またはそれが未選択の場合は設定画面のデフォルトレーティングが使用され、基本Instructionの末尾に ` レーティング: {rating_to_use}` の形で追加されます。
    *   例: `自由に小説を生成してください。 レーティング: r18`

### 1.4 Input文字列とPrompt Suffixの生成 (Current)

#### 1.4.1 メタデータフォーマット (`format_metadata` 関数)

*   UIから取得したメタデータ (`title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`, `dialogue_level`) を、定義された日本語名の順序 (`INPUT_METADATA_ORDER_JA`) に基づいてフォーマットします。
    ```python
    # src/core/prompt_builder.py より
    INPUT_METADATA_ORDER_JA = [
        "タイトル", "キーワード", "ジャンル", "あらすじ", "設定", "プロット", "セリフ量"
    ]
    ```
*   各項目は `# {日本語名}:\n{値}` の形式で表現されます。
*   キーワードとジャンル (リスト形式) は、各要素が改行区切りで結合されます。
*   `idea` モードの場合、`dialogue_level` (セリフ量) はメタデータ文字列に含まれません。
*   各メタデータ項目間は、2つの改行 (`\n\n`) で区切られます。

#### 1.4.2 `GEN_` / `IDEA_` タスクのInputとSuffix

*   **`internal_input`**:
    *   上記 `format_metadata` 関数で生成されたメタデータ文字列が、そのまま `internal_input` となります。
    *   メタデータが全くない場合 (`GEN_ZERO`, `IDEA_ZERO`) は、`internal_input` は空文字列 (`""`) になります。
*   **`prompt_suffix`**:
    *   `GEN_` タスクで、かつ本文が入力されていた場合（タスク判定により有効行数3行以下と判断された場合）、その**入力本文全体**が `prompt_suffix` となります。これはAIに「この書き出しに続けて生成してほしい」という文脈を与えるためです。
    *   それ以外の場合（本文が空の `GEN_` タスク、または `IDEA_` タスク）では、`prompt_suffix` は空文字列になります。

#### 1.4.3 `CONT_` タスクのInputとSuffix (重要: 複雑な形式、変更点多数)

継続タスク (`CONT_INFO`, `CONT_ZERO`)、つまり本文の有効行数が4行以上の場合、AIの出力安定化と文脈理解向上のため、特殊なInput構造とSuffixが用いられます。

1.  **本文分割 (`split_main_text` 関数 - 挙動変更):**
    *   UIの本文エリアのテキスト (`main_text`) が、内部的に3つの部分に分けられる概念となります。
        1.  **`main_part`**: 本文の末尾から4行目より前の部分。
        2.  **`tail`**: 本文の末尾から4行目、3行目、2行目の計3行。これが `internal_input` の一部として利用されます。
        3.  **最終行**: 本文のまさに最後の1行。これが `prompt_suffix` として利用されます。
    *   `split_main_text` 関数自体は、`main_part` と `tail`（上記2と3）を返します。最終行は `build_prompt` 関数内で別途抽出されます。
    *   **注意:** 本文の有効行数が4行未満の場合は、`determine_task_and_instruction` により `GEN_` タスクとして扱われるため、`CONT_` タスクにおけるこの分割ロジックは適用されません。その場合、`split_main_text` は `("", "")` を返し、本文全体が `GEN_` タスクの `prompt_suffix` となります。

2.  **`internal_input` のブロック生成:**
    *   `main_part` (空でない場合): `【本文】\n\`\`\`\n{main_part}\n\`\`\``
    *   メタデータ (存在する場合): `【参考情報】\n\`\`\`\n{metadata_input_string}\n\`\`\``
    *   オーサーズノート (空でない場合): `【オーサーズノート】\n\`\`\`\n{authors_note}\n\`\`\``

3.  **`internal_input` のブロック順序制御:**
    *   ユーザー設定 `cont_prompt_order` (`reference_first` または `text_first`) に基づき、「本文ブロック」と「参考情報ブロック」の順序が決まります。
    *   `reference_first` (デフォルト): 参考情報ブロック → 本文ブロック
    *   `text_first`: 本文ブロック → 参考情報ブロック

4.  **`internal_input` の組み立て:**
    *   決定された順序で「本文ブロック」「参考情報ブロック」を配置します。
    *   その後に「オーサーズノートブロック」を追加します (存在する場合)。
    *   最後に、分割された本文の `tail`（本文の末尾から4,3,2行目）をブロックの外にそのまま追加します。
    *   各ブロック間、および最後の `tail` との間は、単一の改行 (`\n`) で区切られます。
    *   `CONT_ZERO` の場合、メタデータがないため「参考情報ブロック」は生成されません。

5.  **`prompt_suffix` の生成:**
    *   `CONT_` タスクの場合、入力された本文の**有効な最終行1行**が `prompt_suffix` となります。
    *   この `prompt_suffix` は、`[/INST]` タグの直後に付加され、AIに対して「このテキストの直後に続くように生成してほしい」という、より直接的な指示として機能します。これにより、AIが既に生成したかのような文脈を作り出し、自然な継続を促します。

**`CONT_INFO` (reference_first) のプロンプト例:**

Instruction: `参考情報と本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。 レーティング: general` (例)

Internal Input (`internal_input`):
````
【参考情報】
```
# タイトル:
星降る夜の冒険
# キーワード:
ファンタジー
魔法
```
【本文】
```
古い地図を広げると、そこには見たこともない島が描かれていた。
インクが滲んで、一部は判読できない。
```
【オーサーズノート】
```
地図の謎を強調する。
登場人物の驚きを描写。
```
島の中心には奇妙な印がある。
これは一体……？
まさか、これが伝説の……。
````
(上記は `main_part` が「古い地図を～判読できない。」、`tail` が「島の中心には～伝説の……。」の場合の例)

Prompt Suffix (`prompt_suffix`):
`ゴクリと喉を鳴らした。` (例: 本文の実際の最終行)
参考情報→本文の大部分→オーサーズノート→本文の一部という形式です。Text_firstの場合、参考情報と、本文の大部分の挿入順が入れ替わります。

**最終的なプロンプト形式:**
`<s>[INST]{Instruction}\n{internal_input}[/INST]{prompt_suffix}`

### 1.5 最終プロンプト整形 (Mistral形式 - Current - 変更点あり)

選択・整形された `final_instruction`、生成された `internal_input`、そして `prompt_suffix` を以下のように結合します。

```python
# build_prompt 関数内の最終的な整形ロジック
if internal_input:
    # Inputがある場合はInstructionとの間に改行1つ
    prompt = f"<s>[INST]{final_instruction}\n{internal_input}[/INST]{prompt_suffix}"
else:
    # Inputがない場合はInstructionの直後に終了タグ
    prompt = f"<s>[INST]{final_instruction}[/INST]{prompt_suffix}"
```

*   **`prompt_suffix` の追加:** `[/INST]` タグの直後に `prompt_suffix` が付加されるようになりました。
    *   **目的:** AIに対して「このサフィックスは既に書かれたテキストであり、この直後から生成を開始してほしい」という文脈を提供し、特に継続タスクや短い書き出しからの生成の自然さと安定性を向上させることを目指します。
    *   **内容:**
        *   継続タスク（本文4行以上）の場合: 本文の有効な最終1行。
        *   新規生成タスクとして扱われる短い本文（3行以下）の場合: その短い本文全体。
        *   上記以外（本文なしの新規生成、アイデア出し）の場合: 空文字列。
*   システムプロンプトは使用しません。
*   応答は `prompt_suffix` の後に続くことを期待します。

### 1.6 ストップシーケンス (Current)

*   ユーザーが設定画面で指定したストップシーケンスがAPIリクエストに渡されます。
*   デフォルト値は `src/core/settings.py` の `DEFAULT_SETTINGS["stop_sequences"]` で定義されています。

### 1.7 IDEAタスク処理 (`IdeaProcessor` クラス)

IDEAタスク (`current_mode == "idea"`) における項目選択や「高速な手法」チェックボックスの状態に応じた具体的な処理は、`prompt_builder.py` で基本プロンプト (`<s>[INST]...[/INST]`) が生成された後、`src/core/idea_processor.py` 内の `IdeaProcessor` クラスによって実行されます。`IdeaProcessor` は主に以下の役割を担います。

1.  **初期化 (`__init__`)**:
    *   UIの詳細情報タブから現在の入力値 (`title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`) を受け取り、内部に保持します。

2.  **高速モード前提条件チェック (`check_fast_mode_prerequisites`)**:
    *   ユーザーが「高速な手法」をチェックし、かつ特定の項目（例: `synopsis`）を選択した場合に呼び出されます。
    *   選択された項目よりも**前**にある項目（`IDEA_ITEM_ORDER` 配列に基づく順序: `title` -> `keywords` -> ... -> `plot`）がUIで入力されているかを確認します。
    *   もし先行する項目に入力漏れがある場合、`False` と警告メッセージを返します。（UI側でこの警告を表示し、ユーザーは続行を選択できますが、期待通りの結果にならない可能性があることを示唆します。）
    *   先行項目が全て入力されていれば `True` を返します。
    *   **注意:** UIロジックにより、「全体」生成時や最初の項目「タイトル」選択時には「高速な手法」チェックボックス自体が無効化されるため、この関数が呼ばれるのは実質的に2番目以降の項目選択時です。

3.  **Stop Sequence 決定 (`determine_stop_sequence`)**:
    *   ユーザーが特定の項目（「全体」以外）を選択した場合に呼び出されます。
    *   選択された項目の**次**に来る項目のヘッダー文字列（例: 選択項目が `synopsis` なら、次の `setting` のヘッダー `# 設定:`）を特定し、これをStop Sequenceとして返します。これにより、AIが選択された項目を生成し終え、次の項目のヘッダーを出力しようとした時点で生成を停止させます。
    *   「全体」が選択された場合や、最後の項目 (`plot`) が選択された場合は、特定のStop Sequenceは不要なため `None` を返します。

4.  **プロンプト接尾辞生成 (`generate_prompt_suffix`)**:
    *   「高速な手法」が選択され、前提条件が満たされている（または警告を無視して続行された）場合に呼び出されます。
    *   選択された項目よりも**前**にある項目について、UIから取得した入力値をAIの出力形式（`# 日本語名:\n値`、項目間は `\n\n` 区切り）にフォーマットし、結合した文字列を生成します。
    *   この生成された文字列（接尾辞）は、`prompt_builder.py` が生成した基本プロンプトの `[/INST]` タグの**直後**に追加されます。これにより、AIは先行する項目が既に出力されているかのように認識し、選択された項目のヘッダー (`# {選択項目名}:`) から生成を開始することが期待されます。
    *   例: `synopsis` を高速モードで生成する場合、`title`, `keywords`, `genres` の入力値がフォーマットされて `[/INST]` の後に追加され、AIはその続きとして `# あらすじ:` から生成を始めることを狙います。
    *   **注意:** この「プロンプト接尾辞」は `prompt_builder.py` の `prompt_suffix` とは独立した、`IdeaProcessor` 内部の処理です。

5.  **出力フィルタリング (`filter_output`)**:
    *   **「高速な手法」を使用せず**、かつ特定の項目（「全体」以外）を選択した場合に呼び出されます。
    *   この場合、AIはStop Sequence（次の項目のヘッダー）で停止することが期待されますが、完全に停止しなかったり、余分な空白や改行が含まれたりする可能性があるため、念のためフィルタリング処理が行われます。
    *   このメソッドは、AIからの完全な出力文字列 (`full_output`) を受け取り、選択された項目のヘッダー (`# {選択項目名}:`) から、次の項目のヘッダーが現れる直前までを抽出します。
    *   抽出された、選択項目に対応する部分文字列のみを最終的な出力として返します。
    *   **この後処理フィルタリングが必要なため、「高速な手法」を使用しない項目指定生成ではストリーミング表示ができません。**

**処理フローのまとめ:** 
*   **全体生成 (項目指定なし):**
    *   `prompt_builder` が基本プロンプト生成。
    *   `IdeaProcessor` は基本的に関与せず（Stop Sequenceなし）。
    *   API呼び出し (ストリーミング有効)。
*   **項目指定生成 (高速モード OFF):**
    *   `prompt_builder` が基本プロンプト生成。
    *   `IdeaProcessor.determine_stop_sequence` で次の項目のヘッダーをStop Sequenceに設定。
    *   API呼び出し (ストリーミング**無効**)。
    *   `IdeaProcessor.filter_output` でAIの全出力から該当項目部分を抽出（Stop Sequenceで止まらなかった場合の保険）。
*   **項目指定生成 (高速モード ON, ※前提条件OK):**
    *   `prompt_builder` が基本プロンプト生成。
    *   `IdeaProcessor.determine_stop_sequence` で次の項目のヘッダーをStop Sequenceに設定。
    *   `IdeaProcessor.generate_prompt_suffix` で先行項目の文字列を生成。
    *   基本プロンプト (`...[/INST]`) + 接尾辞 + Stop Sequence を用いてAPI呼び出し (ストリーミング有効)。
    *   (フィルタリングは基本的に不要だが、AIがStop Sequenceを無視した場合などに備える可能性はある)

このように、`prompt_builder.py` が提供する一貫した基本プロンプトに対し、`IdeaProcessor` がユーザーの選択に応じてAPIリクエストの内容（Stop Sequence、接尾辞）やレスポンスの処理方法（フィルタリング、ストリーミング有効/無効）を動的に変更することで、IDEAタスクの多様な機能を実現しています。

---

## Part 2: Legacy Prompt Logic (旧仕様)

このセクションでは、過去のバージョン（`legacy` ブランチ相当）で用いられていたプロンプト生成ロジックを記録のために記述します。

### 2.1 基本的な流れ (Legacy)

1.  **タスク判定:** 現在のUI状態（モード、本文有無、詳細情報有無）に基づいてタスクタイプを決定。
2.  **Instruction 選択:** タスクタイプに対応する固定Instructionテンプレートを選択。
3.  **Input 生成:** UIから必要な情報を取得し、タスクタイプに応じた形式でInput文字列を生成。
4.  **最終プロンプト整形:** InstructionとInputをMistral形式テンプレートに合わせて結合。

### 2.2 タスク判定ロジック (Legacy)

以下の条件分岐により、内部タスクタイプが決定されていました。

| 選択中のモード | 本文エリアの状態 | 詳細情報タブの状態 | 決定されるタスクタイプ | 使用Instructionテンプレートキー |
| :------------- | :--------------- | :----------------- | :--------------------- | :---------------------------- |
| **小説生成**   | 空               | **入力あり**       | `GEN_INFO`             | `GEN_INFO`                    |
| **小説生成**   | 空               | 入力なし           | `GEN_ZERO`             | `GEN_ZERO`                    |
| **小説生成**   | **入力あり**     | **入力あり**       | `CONT_INFO`            | `CONT_INFO`                   |
| **小説生成**   | **入力あり**     | 入力なし           | `CONT_ZERO`            | `CONT_ZERO`                   |
| **アイデア出し** | (不問)           | **入力あり**       | `IDEA_INFO`            | `IDEA_INFO`                   |
| **アイデア出し** | (不問)           | 入力なし           | `IDEA_ZERO`            | `IDEA_ZERO`                   |

**補足 (Legacy):**

*   「詳細情報タブの状態」は、`title`, `keywords`, `genres`, `synopsis`, `setting`, `plot` のいずれか1つ以上にユーザーが入力しているかどうかで判定されていました。`authors_note`, `rating`, `dialogue_level` は判定に含まれていませんでした。

### 2.3 固定Instructionテンプレート (Legacy)

以下のテンプレートが使用されていました。レーティング情報は含まれていません。

```python
# 旧バージョンの例
INSTRUCTION_TEMPLATES = {
    "GEN_INFO": "以下の情報に基づいて小説本文を生成してください。",
    "GEN_ZERO": "自由に小説を生成してください。",
    "CONT_INFO": "参考情報を基に以下の文章の続きを生成してください。",
    "CONT_ZERO": "以下の文章の続きを生成してください。",
    "IDEA_INFO": "以下の情報に基づいて、完全な小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
    "IDEA_ZERO": "自由に小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
}
```

### 2.4 Input文字列の生成 (Legacy)

*   **`GEN_INFO` / `GEN_ZERO` / `IDEA_INFO` / `IDEA_ZERO` タスクの場合:**
    1.  詳細情報タブから `title`, `keywords`, `genres`, `synopsis`, `setting`, `plot` を取得。
    2.  定義された順序に基づき `# {日本語名}:\n{値}` 形式で結合。
    3.  キーワードとジャンルは改行区切り。
    4.  項目間は改行2つで区切る。
    5.  入力がない場合は空文字列。
*   **`CONT_INFO` / `CONT_ZERO` タスクの場合:**
    1.  本文エリアのテキスト (`main_text`) を**そのまま全て**取得。
    2.  `CONT_INFO` の場合は、上記と同様にメタデータ文字列 (`metadata_input_string`) を生成。
    3.  最終的な `internal_input` を以下の形式で組み立てていました。**(Current 仕様と大きく異なる点)**
        ```
        【本文】
        ```
        {main_text 全体}
        ```
        {metadata_input_string が存在する場合のみ、以下を追加}
        【参考情報】
        ```
        {metadata_input_string}
        ```
        ```
    4.  `CONT_ZERO` の場合は `【参考情報】...` 部分は追加されません。
    5.  **注意:** 本文の分割、オーサーズノートの挿入、末尾テキストの分離は行われていませんでした。

### 2.5 最終プロンプト整形 (Mistral形式 - Legacy)

InstructionとInputを以下のように結合していました (Current 仕様と同じ形式)。

```python
if internal_input:
    prompt = f"<s>[INST] {instruction_text}\n\n{internal_input} [/INST]"
else:
    prompt = f"<s>[INST] {instruction_text} [/INST]"
```

### 2.6 ストップシーケンス (Legacy)

*   ユーザーが設定画面で指定したストップシーケンス (`stop_sequences` リスト) は、KoboldCpp APIリクエスト時の `stop_sequence` パラメータに渡されます。これにより、モデルが不要なテンプレート文字列を生成した場合などに、そこで生成が停止されます。


---
