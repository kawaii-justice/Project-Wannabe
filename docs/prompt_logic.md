# プロンプト生成ロジック解説 (Project Wannabe 内部仕様)

このドキュメントは、Project Wannabe アプリケーションが、ユーザーの入力（本文、詳細情報など）をどのようにAIへの指示（プロンプト）に変換しているかを解説します。この仕様を理解することで、本アプリケーションの挙動を深く把握し、AIモデルの能力を最大限に引き出すためのデータセットを作成することが可能になります。

**参照コード:** `src/core/prompt_builder.py`, `src/core/context_utils.py`, `src/core/dynamic_prompts.py`

---

## Part 1: プロンプト生成の全体像

このセクションでは、プロンプトが生成されるまでの流れを、技術的な詳細を省いて解説します。

### ◆ 基本的な考え方

Project WannabeがAIと対話する際、単にユーザーの文章をそのまま送っているわけではありません。AIが最高の性能を発揮できるよう、状況に応じて**「AI専用の指示書」**を毎回ゼロから作成しています。この指示書（プロンプト）は、AIが小説の文脈を深く理解し、ユーザーの意図に沿った自然な文章を生成するための、いわば「脚本」や「設計図」の役割を果たします。

### ◆ プロンプト生成の4ステップ

指示書は、大きく分けて4つのステップを経て完成します。

#### Step 1: 状況判断 (タスク判定)
まず、アプリケーションはユーザーが今何をしたいのかを正確に判断します。

*   **本文が空、または数行の書き出し → `新規生成 (GEN)` タスク**
    *   AIは「新しい物語の冒頭」や「短い書き出しに続く文章」を生成するよう指示されます。
*   **本文が十分長い (有効4行以上) → `継続 (CONT)` タスク**
    *   AIは「既存の物語の自然な続き」を生成するよう指示されます。
*   **「アイデア出し」モード → `アイデア出し (IDEA)` タスク**
    *   AIは「物語のプロットや設定」を考案するよう指示されます。

#### Step 2: AIの記憶容量の確認と調整 (動的コンテキスト圧縮)
AIには一度に記憶できる文章量に上限（コンテキスト長）があります。長い小説を書いていると、本文と詳細情報を合わせた指示書が、この上限を超えてしまうことがあります。



この問題を解決するため、アプリケーションはKoboldCpp APIと通信し、AIの記憶容量をリアルタイムで確認します。もし指示書が長すぎると判断した場合、**本文の古い部分（冒頭側）を、記憶容量に収まるギリギリの長さまで自動的にカット**します。



これにより、物語の最新の展開や重要な設定情報が失われることを防ぎ、ユーザーはAIの記憶容量を気にすることなく執筆に集中できます。

#### Step 3: 指示書の部品作成 (Instruction, Input, Suffix)
次に、判断されたタスクと調整後の本文を元に、指示書の各部品を作成します。

*   **Instruction (命令書):** 「小説を書いてください」「この続きを書いてください」といった、AIへの**核心的な命令**です。
*   **Input (参考資料):** タイトル、キーワード、あらすじ、設定、プロットといった詳細情報や、本文の大部分が、AIが読みやすい形式（例: `# タイトル: ...`）に整形されてまとめられます。
*   **Suffix (書き出し):** AIが文章を生成し始める直前の「最後の数行」です。これを指示書の末尾に付けることで、AIは「この文章に滑らかに続くように書けば良いのだな」と理解し、より自然な続きを生成できます。

#### Step 4: 最終プロンプトの完成
最後に、これらの要素（指示文、入力データ、圧縮調整された本文など）が、AIモデル（Wanabiシリーズ）が最も性能を発揮できるように設計された最終的なテンプレートに埋め込まれます。

`[INST]` `(命令書)` `(参考資料)` `[/INST]` `(書き出し)`

この完成した指示書がローカルのKoboldCppに送信され、AIによるテキスト生成が実行されます。


## Part 2: プロンプト生成 詳細技術仕様

このセクションでは、プロンプトを構成する各要素が、どのようなルールに基づいて、どのUI要素から生成されるのかを詳細に解説します。

### 2.1 基本構造 (Mistral Instruct形式)

全てのプロンプトは、以下のMistral Instruct形式テンプレートに基づいて構築されます。

```
[INST]{Instruction}\n{Input}[/INST]{Suffix}
```

*   **`{Instruction}`**: AIに実行してほしいタスクを具体的に指示する命令文。
*   **`{Input}`**: Instructionを補足するための、より詳細な情報。ユーザーが入力したメタデータや本文が含まれます。Inputが存在しない場合は、Instructionと`[/INST]`の間の改行(`\n`)は省略されます。
*   **`{Suffix}`**: `[/INST]`タグの直後に付加されるテキスト。AIは、このテキストの直後から生成を開始するように振る舞います。これにより、文章の自然な継続を強力に促します。

### 2.2 動的プロンプト (Dynamic Prompts)

プロンプト生成プロセスの**最初**に、`evaluate_dynamic_prompt`関数が呼び出され、以下のUI要素内のテキストに含まれる `{A|B|"C D"}` 形式の文字列が処理されます。

*   **適用対象:** タイトル、あらすじ、設定、プロット、オーサーズノート、**本文**
    *   *キーワードとジャンルはタグ単位で適用されますが、プロンプト整形時に処理されます。*
*   **動作:** `{}`内の`|`で区切られた選択肢からランダムに1つが選択され、元のテキストに埋め込まれます。ダブルクォートで囲むことで、スペースを含む選択肢も指定可能です。
*   **以降の全ての処理（タスク判定、圧縮、本文分割など）は、このDynamic Promptsが評価された**後**のテキストに対して行われます。**

### 2.3. 動的コンテキスト圧縮 (`build_prompt_with_compression`関数)

これはプロンプト生成の最上位の処理です。

1.  **利用可能コンテキスト長の算出:**
    *   KoboldCpp APIエンドポイント `GET /api/extra/true_max_context_length` を呼び出し、モデルの実際の最大コンテキスト長 (`true_ctx`) を**毎回取得します（キャッシュしません）**。
    *   `設定` > `生成パラメータ設定` から、現在のタスク（`idea`または`generate`）に応じた`最大出力長 (max_out)` を取得します。
    *   プロンプトが使用できるトークン数の上限を `available_ctx = true_ctx - max_out` として計算します。

2.  **初期トークン数の計測:**
    *   UIから取得した**完全な（圧縮されていない）本文**とその他情報を用いて、後述の`build_prompt`関数で仮のプロンプトを生成します。
    *   KoboldCpp APIエンドポイント `POST /api/extra/tokencount` を呼び出し、仮プロンプトの合計トークン数 (`total_tokens`) を計測します。

3.  **圧縮処理の実行:**
    *   `total_tokens <= available_ctx` の場合、圧縮は不要と判断し、仮プロンプトをそのまま返します。
    *   `total_tokens > available_ctx` の場合、`設定` > `生成パラメータ設定` > `最大コンテキスト超過時の処理`で選択されたモードに基づき、以下の処理を実行します。
        *   **モード: `token_dynamic` (本文をトークン数に基づき圧縮)**
            1.  本文単体のトークン数 (`body_tokens`) を`tokencount` APIで計測し、1文字あたりのトークン数 (`tokens_per_char`) を算出します。
            2.  本文以外の要素（Instruction, メタデータ等）のトークン数を `other_tokens_est = total_tokens - body_tokens` として推定します。
            3.  本文に割り当て可能なトークン数を `available_for_body = available_ctx - other_tokens_est` として計算します。
            4.  格納できると推定される本文の文字数を `est_body_chars = available_for_body / tokens_per_char` として算出します。
            5.  探索開始位置を `start_index = len(main_text) - est_body_chars - token_compression_offset_chars` として決定します。これにより、明らかに長すぎる部分をスキップし、効率的に探索を開始します。
            6.  `start_index`から、`token_compression_step_chars`（例: 100文字）ずつ本文の先頭を削りながらループ処理を行います。
            7.  ループごとに、削られた本文で仮プロンプトを再生成し、トークン数を計測します。
            8.  トークン数が`available_ctx`を初めて下回った時点で、そのプロンプトを最終結果として採用し、ループを終了します。
            9.  ループが終了しても収まらなかった場合、ループ中で最もトークン数が少なかったプロンプトを、`is_overflow=True`フラグと共に返します。
        *   **モード: `char_trim` (最大本文文字数にトリム)**
            *   設定された`max_main_text_chars`の値に基づき、`truncated_text = main_text[-max_main_text_chars:]` として本文の先頭をカットし、プロンプトを再生成します。
        *   **モード: `none` (何もしない)**
            *   圧縮処理は行わず、`is_overflow=True`フラグと共に、超過したままの初期プロンプトを返します。メインのUI処理側でこのフラグを検知し、エラーダイアログを表示して生成を中止します。

### 2.4. タスク判定 (`determine_task_and_instruction`関数)

圧縮後の最終的な本文を元に、実行すべき内部タスクを以下のルールで厳密に判定します。

*   **有効行数 (Content Lines):** 本文を改行で分割し、空白文字を除去した結果、1文字以上残る行の数。
*   **メタデータ有無 (Has Metadata):** `title`, `keywords`, `genres`, `synopsis`, `setting`, `plot`, `dialogue_level` のうち、一つでも値が設定されているか。 (`idea`モードでは`dialogue_level`は無視)。

| モード (`current_mode`) | 本文の状態 (有効行数) | メタデータ有無 | 決定タスク |
| :--- | :--- | :--- | :--- |
| `generate` | 0 | あり | `GEN_INFO` |
| `generate` | 0 | なし | `GEN_ZERO` |
| `generate` | 1, 2, 3 | あり | `GEN_INFO` |
| `generate` | 1, 2, 3 | なし | `GEN_ZERO` |
| `generate` | 4以上 | あり | `CONT_INFO` |
| `generate` | 4以上 | なし | `CONT_ZERO` |
| `idea` | (不問) | あり | `IDEA_INFO` |
| `idea` | (不問) | なし | `IDEA_ZERO` |

### 2.5. `Instruction`の構築

1.  **テンプレート選択:** 上記で決定されたタスクタイプに基づき、以下のテンプレートからInstructionを選択します。
    ```python
    INSTRUCTION_TEMPLATES = {
        "GEN_INFO": "以下の情報に基づいて小説本文を生成してください。",
        "GEN_ZERO": "自由に小説を生成してください。",
        "CONT_INFO": "参考情報と本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。",
        "CONT_ZERO": "本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。",
        "IDEA_INFO": "以下の情報に基づいて、完全な小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
        "IDEA_ZERO": "自由に小説のアイデア（タイトル、キーワード、ジャンル、あらすじ、設定、プロット）を生成してください。",
    }
    ```
2.  **レーティング付加:** `設定`のデフォルト値、またはUIで上書きされた値（`general` or `r18`）を ` レーティング: {rating}` の形式でInstructionの末尾に連結します。

### 2.6. `Input`と`Suffix`の構築 (`build_prompt`関数)

#### 2.6.1. `GEN_` / `IDEA_` タスク
*   **`Input`**: 詳細情報タブの各項目を、以下のルールでフォーマットした文字列。
    *   **順序:** `タイトル`, `キーワード`, `ジャンル`, `あらすじ`, `設定`, `プロット`, `セリフ量` の固定順。
    *   **形式:** `# {日本語名}:\n{値}`
    *   **リスト項目:** `キーワード`, `ジャンル`は各要素を改行で連結。
    *   **区切り:** 各項目間は2つの改行(`\n\n`)で区切る。
    *   *`idea`モードでは`セリフ量`は含まれない。*
*   **`Suffix`**:
    *   タスクタイプが`GEN_`で、かつ本文（有効3行以下）が存在する場合、その**本文全体**が`Suffix`となる。
    *   それ以外は空文字列 (`""`)。

#### 2.6.2. `CONT_` タスク (有効行数4行以上)
継続タスクのプロンプトは、本文末尾の状態によって分岐する最も複雑なロジックを持ちます。

1.  **分岐条件: `is_sentence_complete(main_text)`**
    *   まず、本文の末尾が「。」、「」」、または改行文字で終わっているか（=文章として完結しているか）を判定します。

2.  **Path A: 文章が完結している場合**
    *   **`Suffix`**: **空文字列 (`""`)** になります。
    *   **`tail`**: 本文の末尾から、**最後の有効行を含む3行**を抽出します。
    *   **`main_part`**: 本文全体から`tail`部分を除いた、それより前の全ての部分です。

3.  **Path B: 文章が途中で終わっている場合**
    *   **`Suffix`**: 本文の**有効な最終行1行**を`strip()`したものが`Suffix`になります。
    *   **`split_main_text`関数による分割:**
        *   **`tail`**: 残りの本文（Suffixになった最終行を除く）に対して、**最後から2番目の有効行を終点とする3行のブロック**が`tail`となります。
        *   **`main_part`**: 残りの本文全体から、`tail`部分を除いた、それより前の全ての部分です。

4.  **`Input`ブロックの構築と順序:**
    *   以下の3種類のブロックが、中身が存在する場合のみ生成されます。
        *   `【参考情報】\n\`\`\`\n{メタデータ文字列}\n\`\`\``
        *   `【本文】\n\`\`\`\n{main_part}\n\`\`\``
        *   `【この先の展開についての指示・メモ】\n\`\`\`\n{オーサーズノート文字列}\n\`\`\``
            *   *注意: `設定` > `プロンプトフォーマット` で `レガシー` を選択すると、ヘッダーは `【オーサーズノート】` に変わります。*
    *   **`Input`の組み立て順:**
        1.  `設定`の`cont_prompt_order`に基づき、「参考情報ブロック」と「本文ブロック」を配置 (`reference_first`がデフォルト)。
        2.  次に「オーサーズノートブロック」を配置。
        3.  最後に、ブロックの外に**`tail`の文字列**をそのまま配置。
        4.  各ブロック間、および`tail`との間は、単一の改行(`\n`)で区切られます。

---
#### **完全なプロンプト生成例 (`CONT_INFO`タスク)**

*   **ユーザーのUI状態:**
    *   **モード:** `generate`
    *   **詳細情報:** `タイトル: "刻の迷宮"`, `オーサーズノート: "主人公の{焦り|恐怖}を強調"`
    *   **本文 (5行):**
        ```
        時計の針が逆回転を始めた。
        風景がぐにゃりと歪む。
        壁に飾られた絵画の人物が、ゆっくりとこちらを向いた。
        彼は口を開き、何かを伝えようとしている。
        その唇が形作ったのは
        ```
        (有効5行 → `CONT_`タスク。文章は途中で終了 → **Path B**)

*   **プロンプト生成プロセス:**
    1.  **Dynamic Prompts評価:** オーサーズノートが `"主人公の焦りを強調"` または `"主人公の恐怖を強調"` のどちらかに確定する。ここでは「焦り」が選ばれたとする。
    2.  **動的圧縮:** トークン数が上限を超えていないと仮定。本文はそのまま。
    3.  **タスク判定:** `CONT_INFO`に決定。
    4.  **Instruction生成:** `"参考情報と本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。 レーティング: general"`
    5.  **本文分割 (Path B):**
        *   **`Suffix`**: `"その唇が形作ったのは"`
        *   **`split_main_text`適用対象:**
            ```
            時計の針が逆回転を始めた。
            風景がぐにゃりと歪む。
            壁に飾られた絵画の人物が、ゆっくりとこちらを向いた。
            彼は口を開き、何かを伝えようとしている。
            ```
        *   **`tail`**: `"風景がぐにゃりと歪む。\n壁に飾られた絵画の人物が、ゆっくりとこちらを向いた。\n彼は口を開き、何かを伝えようとしている。"` (最後から2番目の有効行 `彼は...` を終点とする3行)
        *   **`main_part`**: `"時計の針が逆回転を始めた。"`
    6.  **Inputブロック生成:**
        *   **参考情報ブロック:** `【参考情報】\n\`\`\`\n# タイトル:\n刻の迷宮\n\`\`\``
        *   **本文ブロック:** `【本文】\n\`\`\`\n時計の針が逆回転を始めた。\n\`\`\``
        *   **オーサーズノートブロック:** `【この先の展開についての指示・メモ】\n\`\`\`\n主人公の焦りを強調\n\`\`\``
    7.  **Input組み立て (デフォルト順):** `参考情報ブロック` + `\n` + `本文ブロック` + `\n` + `オーサーズノートブロック` + `\n` + `tail`

*   **最終的に生成されるプロンプト:**
````
[INST]参考情報と本文を踏まえ、最後の文章の自然な続きとなるように小説を生成してください。 レーティング: general
【参考情報】
```
# タイトル:
刻の迷宮
```
【本文】
```
時計の針が逆回転を始めた。
```
【この先の展開についての指示・メモ】
```
主人公の焦りを強調
```
風景がぐにゃりと歪む。
壁に飾られた絵画の人物が、ゆっくりとこちらを向いた。
彼は口を開き、何かを伝えようとしている。[/INST]その唇が形作ったのは    
    
````